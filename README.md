# SystemControl_2025

JupyterLab 環境構築・利用ガイド
# SystemControl_2025 JupyterLab 環境構築・利用ガイド

このガイドでは、Python環境の構築（pyenv経由）、JupyterLabのインストール、および基本的な利用方法について解説します。

## 1. 環境構築 (Pythonのインストール)

`pip` コマンドが使用できない場合や、まだPythonをインストールしていない場合は、以下の手順で `pyenv` を経由してPythonをインストールしてください。

※すでにインストール済みの方は「2. JupyterLabのインストール」へ進んでください。

### 1-1. pyenvのインストール
ターミナルで以下のコマンドを実行し、`pyenv` をインストールします。

```bash
brew install pyenv
```

### 1-2. 初期設定
インストール後、以下のコマンドを順に実行して環境設定ファイル（`.zshrc`）に必要な設定を追記し、読み込みます。

```bash
touch .zshrc
echo 'export PYENV_ROOT="$HOME/.pyenv"' >> ~/.zshrc
echo 'command -v pyenv >/dev/null || export PATH="$PYENV_ROOT/bin:$PATH"' >> ~/.zshrc
echo 'eval "$(pyenv init -)"' >> ~/.zshrc
source .zshrc
```

インストール確認のため、以下を実行してバージョンが表示されるか確認してください。

```bash
pyenv -v
```

### 1-3. Pythonのインストールと設定
今回はバージョン 3.13.7 を使用します。

```bash
pyenv install 3.13.7
pyenv global 3.13.7
```

※ pip install jupyterlab 実行時に pip コマンドが見つからないエラーが出た場合も、上記の pyenv global コマンドを実行してください。


## 2. JupyterLabのインストールと起動

### 2-1. インストール
ターミナルで以下のコマンドを実行します。

```bash
pip install jupyterlab
```

### 2-2. 起動
インストール完了後、以下のコマンドでJupyterLabを起動します。

```bash
jupyter lab
```

## 3. JupyterLabの基本的な使い方
フォルダ・ファイルの作成と管理

フォルダ作成: 左上のタブメニューにある「＋」ボタン（左から2番目）を押して新規フォルダを作成します。

名前の変更: 作成されたフォルダを右クリック（トラックパッド2本指クリック）し、メニューから「Rename」を選択して変更します。

ファイル作成: タブメニュー左端の「＋」ボタンを押し、表示されるメニューから「Notebook」の「Python 3」を選択して作成します。

ノートブックの操作

セルの実行: Shift + Return（Enter） 

改行: Return（Enter） 

カーネルの再起動: 上部メニューの右から2番目のボタン（回転矢印）を押すと、変数の状態などがリセットされ、最初の状態に戻ります 。

セルの種類
セル上部のプルダウンメニューから種類を切り替えることができます 。

Code: Pythonプログラムを記述し、実行するためのセル 。

Markdown: メモ、見出し、箇条書きなどの文章を書くためのセル 。

カーネル（Kernel）とは コードセルの内容を受け取り 、計算を実行し 、その結果やグラフを出力エリアに返す  裏方のプログラムです。


## 4. 日本語化（オプション）
JupyterLabを日本語で使用したい場合は、言語パックをインストールします。

JupyterLabが起動している場合は、ターミナルで Control + C を押して一度終了させます 。

以下のコマンドを実行します 。

```bash
pip install jupyterlab jupyterlab-language-pack-ja-JP
```

再度 jupyter lab コマンドで起動します 。


p5.js 倒立振子制御学習支援システム
# 倒立振子制御学習支援シミュレーター：詳細仕様書（README）

## 1. 概要
本教材は、Pythonでの理論設計とJavaScriptによる動的シミュレーションを統合した学習システムです。以下の各ファイルは、制御理論の発展段階（LQR → ノイズ発生 → LPF対策 → KF対策）に対応しています。

## 2. 制御・フィルタのアルゴリズムと関数名

### A. 状態フィードバック制御 (LQR)
Jupyterで算出した最適な重みを適用し、システムを安定化させます。
* **ファイル**: `倒立振子_FB.html`
* **主要な変数・関数**:
    * `Gain (F1-F4)`: Jupyterの `F_lqr` に対応。
    * `u = - (k1 * x_m + k2 * x_dot_m + k3 * theta + k4 * theta_dot)`: 制御入力の計算式。
* **学習ポイント**: ゲインを書き換えた際、収束の速さとカートの移動量のトレードオフを観察する。

### B. 数値微分と観測ノイズ
現実のセンサ特性（ノイズ）を導入し、単純な微分計算の限界を学びます。
* **ファイル**: `倒立振子_FB_white2.html`
* **主要な変数・関数**:
    * `noise_val_x`, `noise_val_theta`: `randomGaussian()` で生成される白色雑音。
    * `x_dot_m = (x_m - x_prev) / dt`: オイラー前進差分による数値微分。
* **学習ポイント**: 微小なノイズが微分によって増幅され、制御 $u$ が激しく振動することを確認する。

### C. ローパスフィルタ (LPF)
高周波ノイズを除去する標準的な手法とその副作用を学びます。
* **ファイル**: `倒立振子_FB_RPSWhite2.html`
* **主要な変数・関数**:
    * `calc_alpha_fe(fc, dt)`: カットオフ周波数から重み係数 $\alpha$ を算出。
    * `y[k] = (1 - alpha) * y[k-1] + alpha * x[k]`: 1次遅れフィルタの漸化式。
* **学習ポイント**: ノイズは消えるが、**位相遅れ（反応の遅延）**によって振子が発散（転倒）する様子を体験する。



### D. カルマンフィルタ (KF)
物理モデルを用いた最適推定により、遅延なくノイズを除去します。
* **ファイル**: `倒立振子_FB_ka.html`
* **主要なクラス・関数**:
    * `class SimpleKalmanFilter`: 予測と更新のロジックを保持するクラス。
    * `predict(dt, q_scale)`: 物理法則に基づく状態予測（タイム更新）。
    * `update(measurement, r_noise_std)`: 観測値を用いた推定値の修正（観測更新）。
* **学習ポイント**: `Q`（モデルの信頼性）と `R`（センサの信頼性）のバランスを調整し、遅延のない滑らかな推定を実現する。



## 3. 変数・パラメータの対応表

| 分類 | Jupyter変数 (Python) | p5.js変数 (JavaScript) | 物理的な意味 |
| :--- | :--- | :--- | :--- |
| **物理量** | `x`, `x_dot`, `theta`, `theta_dot` | `x_m`, `x_dot_m`, `theta`, `theta_dot` | カート位置、速度、角度、角速度 |
| **ゲイン** | `F_lqr` (行列) | `k1, k2, k3, k4` (数値) | フィードバックゲイン |
| **ノイズ** | `noise_x_std_dev` | `current_noise_std_x` | 観測ノイズの標準偏差 |
| **KF調整** | `QN` (プロセスノイズ) | `q_pos`, `q_angle` | モデルをどれだけ信じるか |
| **KF調整** | `RN` (観測ノイズ) | `r_pos_param`, `r_angle_param` | センサをどれだけ信じるか |

## 4. 実行環境のセットアップ
1.  **JupyterLab**: `倒立振子制御.ipynb` を実行して設計パラメータを得る。
2.  **ブラウザ統合**: 各HTMLファイルを Jupyter のセル内で以下のコードにより呼び出し可能。
    ```python
    from IPython.display import IFrame
    IFrame(src='倒立振子_FB_ka.html', width=1000, height=800)
    ```

## 5. 注意事項（モデルの乖離）
Jupyterでの設計は角度が小さいことを前提とした**「線形モデル」**ですが、p5.jsのシミュレーションは実際の物理法則に近い**「非線形モデル」**で動作しています。このため、角度が大きくなりすぎると線形設計のゲインでは支えきれず、振子が倒れることがあります。これは教材としての意図的な仕様です。

