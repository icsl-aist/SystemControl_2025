<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>倒立振子（オイラー前進差分 LPF版）- 目盛り・凡例付き</title>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.6.0/lib/p5.min.js"></script>
  <style>
    body { font-family: sans-serif; text-align: center; margin: 0; padding-top: 5px; }
    #controls { margin: 5px auto; display: flex; justify-content: center; align-items: flex-start; flex-wrap: wrap; gap: 10px; max-width: 980px; }
    .control-group { border: 1px solid #ccc; padding: 6px 10px; border-radius: 4px; display: flex; flex-direction: column; gap: 4px; background-color: #fff; min-width: 110px; }
    .control-group strong { font-size: 0.85rem; margin-bottom: 2px; border-bottom: 1px solid #eee; padding-bottom: 2px; text-align: center; display: block; }
    .input-pair { display: flex; justify-content: space-between; align-items: center; width: 100%; }
    .input-pair label { font-size: 0.8rem; margin-right: 5px; white-space: nowrap; }
    input { width: 50px; padding: 2px; font-size: 0.85rem; border: 1px solid #999; border-radius: 2px; text-align: right; }
    .note { font-size: 0.7rem; color: #666; text-align: center; }
    h3 { margin: 5px 0; font-size: 1.2rem; }
    .button-container { display: flex; align-items: center; height: 100%; padding-top: 30px; }
    button { padding: 8px 16px; cursor: pointer; font-size: 0.85rem; background-color: #f0f0f0; border: 1px solid #999; border-radius: 3px; }
    button:active { background-color: #ddd; }
    
    /* 凡例のスタイル */
    .legend-box {
      display: flex; justify-content: center; gap: 20px; margin: 10px auto 5px;
      font-size: 0.9rem; font-family: monospace;
    }
    .legend-item { display: flex; align-items: center; }
    .legend-color { width: 12px; height: 12px; margin-right: 5px; display: inline-block; }

    #info-box { width: 900px; margin: 5px auto; padding: 5px; border: 1px solid #888; background: #f9f9f9; text-align: left; font-family: monospace; font-size: 0.9rem; }
    canvas { display: block; margin: 5px auto; border: 1px solid #ccc; }
  </style>
</head>

<body>
  
  <div id="controls">
    <div class="control-group">
      <strong>Gain</strong>
      <div class="input-pair"><label>F1(x)</label><input type="number" id="k1" value="1" step="0.1" /></div>
      <div class="input-pair"><label>F2(ẋ)</label><input type="number" id="k2" value="3.96" step="0.1" /></div>
      <div class="input-pair"><label>F3(θ)</label><input type="number" id="k3" value="-38.8" step="0.1" /></div>
      <div class="input-pair"><label>F4(θ̇)</label><input type="number" id="k4" value="-9.11" step="0.1" /></div>
    </div>

    <div class="control-group" style="background-color: #fff0f0;">
      <strong>Noise(Std)</strong>
      <div class="input-pair"><label>x</label><input type="number" id="noise_std_x" value="0.05" step="0.01" min="0"/></div>
      <div class="input-pair"><label>θ</label><input type="number" id="noise_std_theta" value="0.05" step="0.001" min="0"/></div>
    </div>

    <div class="control-group" style="background-color: #f0f0ff;">
      <strong>Cutoff Freq (Hz)</strong>
      <div class="input-pair"><label>fc(x)</label><input type="number" id="fc_x" value="20" step="0.1" min="0"/></div>
      <div class="input-pair"><label>fc(θ)</label><input type="number" id="fc_theta" value="20" step="0.1" min="0"/></div>
      <span class="note">(α = 2π*fc*dt)</span>
    </div>

    <div class="button-container">
        <button onclick="resetSystem()">リセット</button>
    </div>
  </div>

  <div class="legend-box">
    <div class="legend-item"><span class="legend-color" style="background: #00aa00;"></span>真値 (True State)</div>
    <div class="legend-item"><span class="legend-color" style="background: #ff9900; opacity: 0.6;"></span>観測値 (Noisy Sensor)</div>
    <div class="legend-item"><span class="legend-color" style="background: #0000ff;"></span>推定値 (Filtered/Estimated)</div>
  </div>

  <div id="info-box"><pre id="info">Loading...</pre></div>

  <script>
    // --- 状態変数 ---
    let x, x_dot, theta, theta_dot, u;
    
    // --- 観測・フィルタ用変数 ---
    let x_real = 0;           // ノイズ付き観測値 (位置)
    let theta_real = 0;       // ノイズ付き観測値 (角度)
    
    let x_real_rpf = 0;       // フィルタ後の推定値 (位置)
    let theta_real_rpf = 0;   // フィルタ後の推定値 (角度)

    // 1ステップ前の観測値 (オイラー前進差分用)
    let x_real_prev = 0;
    let theta_real_prev = 0;
    
    let lastSimTime = 0;

    // --- グラフ履歴用 ---
    let xHistory = [], xDotHistory = [];               // x: 真値, xDotHistory: 推定速度
    let thetaHistory = [], thetaDotHistory = [];       // θ: 真値, thetaDotHistory: 推定角速度
    
    // 真値の速度履歴（重ね描き用）
    let xDotTrueHistory = [], thetaDotTrueHistory = [];
    
    // ノイズ・フィルタ履歴用
    let xRealHistory = [], xRpfHistory = [];
    let thetaRealHistory = [], thetaRpfHistory = [];
    
    const MAX_HISTORY = 1000; 

    // --- システムパラメータ ---
    const g = 9.8;
    const fps = 60;
    const dt = 0.005; 
    const M = 1.0;   
    const m = 0.5;   
    const l = 1.0;   
    const damping_x = 0.3;
    const damping_theta = 0.2;
    const px2m = 1.0 / 100; 

    // --- ノイズパラメータ ---
    let noise_actuator = 0; 
    let noise_sensor_x = 0;  
    let noise_sensor_theta = 0;  
    const K_noise_actuator = 10; 

    function setup() {
      createCanvas(1000, 730); 
      frameRate(fps);
      resetSystem();
      textFont('monospace', 14);
    }

    function draw() {
      background(255);
      const now = millis() / 1000;

      while (lastSimTime + dt <= now) {
        simulate(dt); 
        lastSimTime += dt;
      }
      
      drawGraphs(); 
      drawCart();
      updateInfo();
    }

    function simulate(dt) {
        const k1 = parseFloat(document.getElementById("k1").value);
        const k2 = parseFloat(document.getElementById("k2").value);
        const k3 = parseFloat(document.getElementById("k3").value);
        const k4 = parseFloat(document.getElementById("k4").value);

        const std_x = parseFloat(document.getElementById("noise_std_x").value);
        const std_theta = parseFloat(document.getElementById("noise_std_theta").value);

        const fc_x = parseFloat(document.getElementById("fc_x").value);
        const fc_theta = parseFloat(document.getElementById("fc_theta").value);

        // Alphaを計算 (α = 2π * fc * dt)
        const alpha_x = 2 * Math.PI * fc_x * dt;
        const alpha_theta = 2 * Math.PI * fc_theta * dt;
        
        const x_m = (x - width/2) * px2m; 
        const x_dot_m = x_dot * px2m;
 
        // --- 1. センサノイズの生成 ---
        noise_sensor_x = randomGaussian(0, std_x);
        noise_sensor_theta = randomGaussian(0, std_theta);
        
        x_real = x_m + noise_sensor_x;
        theta_real = theta + noise_sensor_theta;       

        // --- 2. ローパスフィルタ (RPF) ---
        const x_real_rpf_new = (1 - alpha_x) * x_real_rpf + alpha_x * x_real_prev;
        const theta_real_rpf_new = (1 - alpha_theta) * theta_real_rpf + alpha_theta * theta_real_prev;

        const x_dot_est = (x_real_rpf_new - x_real_rpf) / dt;
        const theta_dot_est = (theta_real_rpf_new - theta_real_rpf) / dt;

        x_real_rpf = x_real_rpf_new;
        theta_real_rpf = theta_real_rpf_new;

        // --- 3. 外乱ノイズ ---
        const r = Math.random();
        if (r < 0.05) noise_actuator = -1;
        else if (r > 0.95) noise_actuator = 1;
        else noise_actuator = 0;

        // --- 4. 制御入力 ---
        u = - (k1 * x_real_rpf + k2 * x_dot_est + k3 * theta_real_rpf + k4 * theta_dot_est)
            + noise_actuator * K_noise_actuator;

        // --- 5. 物理演算 ---
        const sinT = Math.sin(theta);
        const cosT = Math.cos(theta);
        const totalMass = M + m;
        const theta_ddot = (g * sinT - cosT * (u + m * l * theta_dot ** 2 * sinT) / totalMass) /
                           (l * (1 - m * cosT * cosT / totalMass)) - damping_theta * theta_dot;
        const x_ddot = (u + m * l * (theta_dot ** 2 * sinT - theta_ddot * cosT) ) / totalMass - damping_x * x_dot;

        x_dot += x_ddot * dt;
        x += x_dot * dt;
        theta_dot += theta_ddot * dt;
        theta += theta_dot * dt;
        
        x = constrain(x, 50, width - 50);

        // --- 6. 履歴の保存 ---
        xHistory.push(x_m);                 // 真値
        xDotTrueHistory.push(x_dot_m);      // 真値
        xDotHistory.push(x_dot_est);        // 推定値

        thetaHistory.push(theta);           // 真値
        thetaDotTrueHistory.push(theta_dot);// 真値
        thetaDotHistory.push(theta_dot_est);// 推定値
        
        xRealHistory.push(x_real);          // 観測値
        xRpfHistory.push(x_real_rpf);       // フィルタ後
        
        thetaRealHistory.push(theta_real);  // 観測値      
        thetaRpfHistory.push(theta_real_rpf);// フィルタ後   

        if (thetaHistory.length > MAX_HISTORY) {
            xHistory.shift(); xDotHistory.shift(); xDotTrueHistory.shift();
            thetaHistory.shift(); thetaDotHistory.shift(); thetaDotTrueHistory.shift();
            xRealHistory.shift(); xRpfHistory.shift();
            thetaRealHistory.shift(); thetaRpfHistory.shift();
        }

        x_real_prev = x_real;
        theta_real_prev = theta_real;
    }

    function drawCart() {
      const cartY = height - 150; 
      stroke(200); strokeWeight(1);
      line(0, cartY + 35, width, cartY + 35);

      fill(100, 180, 255); stroke(0); strokeWeight(1); 
      rectMode(CENTER);
      rect(x, cartY, 100, 30, 10);
      fill(0);
      ellipse(x - 30, cartY + 25, 20, 20);
      ellipse(x + 30, cartY + 25, 20, 20);

      const l_px = l * 100;
      const pendulumX = x - l_px * Math.sin(theta);
      const pendulumY = cartY - l_px * Math.cos(theta);

      stroke(0); strokeWeight(6);
      line(x, cartY, pendulumX, pendulumY);
      fill(0); ellipse(pendulumX, pendulumY, 20, 20);
      rectMode(CORNER); 
    }

    function resetSystem() {
      x = width / 2; x_dot = 0;
      theta = 0.1; theta_dot = 0;
      lastSimTime = millis() / 1000;
      noise_actuator = 0;
      
      const x0_m = (x - width/2) * px2m;
      x_real = x0_m; theta_real = theta;
      x_real_rpf = x0_m; theta_real_rpf = theta;
      x_real_prev = x0_m; theta_real_prev = theta;
      
      xHistory = []; xDotHistory = []; xDotTrueHistory = [];
      thetaHistory = []; thetaDotHistory = []; thetaDotTrueHistory = [];
      xRealHistory = []; xRpfHistory = [];
      thetaRealHistory = []; thetaRpfHistory = [];
    }

    function updateInfo() {
      const fc_x = parseFloat(document.getElementById("fc_x").value);
      const fc_theta = parseFloat(document.getElementById("fc_theta").value);

      document.getElementById("info").textContent =
        `Filter Cutoff: fc_x=${fc_x}Hz, fc_θ=${fc_theta}Hz\n` +
        `u : ${u.toFixed(2)} N`;
    }

    // ★★★ グラフ描画関数（配置変更版） ★★★
    function drawGraphs() {
      const gW = 450;
      const gH = 100;
      const gX1 = 45;  // 左側X座標
      const gX2 = 545; // 右側X座標
      const gY1 = 10;  // 上段Y座標
      const gY2 = 120; // 下段Y座標

      // ==========================================
      // 上段: カート系 (Position, Velocity)
      // ==========================================

      // 左上: カート位置 (x)
      plotGraphShell(gX1, gY1, gW, gH, "Cart Position (x) [m]", -5.0, 5.0, true);
      plotGraphData(gX1, gY1, gW, gH, xRealHistory, -5.0, 5.0, color(255, 150, 0, 100), 1);   // Noisy (Orange)
      plotGraphData(gX1, gY1, gW, gH, xRpfHistory, -5.0, 5.0, color(0, 0, 255), 2);          // Filtered (Blue)
      plotGraphData(gX1, gY1, gW, gH, xHistory, -5.0, 5.0, color(0, 150, 0), 2);            // True (Green)

      // 右上: カート速度 (x_dot)
      plotGraphShell(gX2, gY1, gW, gH, "Cart Velocity (x_dot) [m/s]", -5.0, 5.0, true);
      plotGraphData(gX2, gY1, gW, gH, xDotHistory, -5.0, 5.0, color(0, 0, 255), 2);         // Estimated (Blue)
      plotGraphData(gX2, gY1, gW, gH, xDotTrueHistory, -5.0, 5.0, color(0, 150, 0), 2);    // True (Green)

      // ==========================================
      // 下段: 振子系 (Angle, Ang. Velocity)
      // ==========================================

      // 左下: 角度 (theta)
      plotGraphShell(gX1, gY2, gW, gH, "Angle (theta) [rad]", -5.0, 5.0, true);
      plotGraphData(gX1, gY2, gW, gH, thetaRealHistory, -5.0, 5.0, color(255, 150, 0, 100), 1); // Noisy (Orange)
      plotGraphData(gX1, gY2, gW, gH, thetaRpfHistory, -5.0, 5.0, color(0, 0, 255), 2);        // Filtered (Blue)
      plotGraphData(gX1, gY2, gW, gH, thetaHistory, -5.0, 5.0, color(0, 150, 0), 2);           // True (Green)

      // 右下: 角速度 (theta_dot)
      plotGraphShell(gX2, gY2, gW, gH, "Angular Velocity (theta_dot) [rad/s]", -5.0, 5.0, true);
      plotGraphData(gX2, gY2, gW, gH, thetaDotHistory, -5.0, 5.0, color(0, 0, 255), 2);       // Estimated (Blue)
      plotGraphData(gX2, gY2, gW, gH, thetaDotTrueHistory, -5.0, 5.0, color(0, 150, 0), 2);  // True (Green)
    }

    // 目盛りと枠を描画する関数
    function plotGraphShell(x, y, w, h, title, yMin, yMax, zeroLine) {
      push(); translate(x, y); 
      stroke(200); fill(250); rect(0, 0, w, h);

      // --- 目盛り(グリッドと数値) ---
      const steps = 4;
      textSize(10); textAlign(RIGHT, CENTER); noStroke(); fill(80);
      for (let i = 0; i <= steps; i++) {
        let val = lerp(yMax, yMin, i / steps); 
        let yPos = map(val, yMin, yMax, h, 0);
        stroke(230); strokeWeight(1);
        if (i === 0 || i === steps) stroke(200); 
        line(0, yPos, w, yPos);
        noStroke();
        text(val.toFixed(1), -5, yPos);
      }

      // タイトルとゼロ線
      fill(0); noStroke(); textAlign(LEFT, TOP); textSize(12); text(title, 5, 5);
      if (zeroLine) {
        stroke(200, 100, 100, 150); strokeWeight(1);
        const yZero = map(0, yMin, yMax, h, 0);
        if (yZero >= 0 && yZero <= h) line(0, yZero, w, yZero);
      }
      pop();
    }
    
    // データをプロットする関数（クリッピング付き）
    function plotGraphData(x, y, w, h, data, yMin, yMax, c, weight) {
      push(); translate(x, y);
      drawingContext.save();
      drawingContext.beginPath();
      drawingContext.rect(0, 0, w, h);
      drawingContext.clip();

      stroke(c); strokeWeight(weight); noFill();
      beginShape();
      for (let i = 0; i < data.length; i++) {
        const xPixel = map(i, 0, MAX_HISTORY - 1, 0, w);
        const yPixel = map(data[i], yMin, yMax, h, 0);
        vertex(xPixel, yPixel);
      }
      endShape();
      
      drawingContext.restore(); 
      pop(); 
    }
  </script>
</body>
</html>